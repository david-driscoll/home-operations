// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClientBlockedServicesPauseSchedule {
    /**
     * Paused service blocking interval for `Friday`
     */
    fri: outputs.ClientBlockedServicesPauseScheduleFri;
    /**
     * Paused service blocking interval for `Monday`
     */
    mon: outputs.ClientBlockedServicesPauseScheduleMon;
    /**
     * Paused service blocking interval for `Saturday`
     */
    sat: outputs.ClientBlockedServicesPauseScheduleSat;
    /**
     * Paused service blocking interval for `Sunday`
     */
    sun: outputs.ClientBlockedServicesPauseScheduleSun;
    /**
     * Paused service blocking interval for `Thursday`
     */
    thu: outputs.ClientBlockedServicesPauseScheduleThu;
    /**
     * Time zone name according to IANA time zone database. For example `America/New_York`. `Local` represents the system's local time zone.
     */
    timeZone?: string;
    /**
     * Paused service blocking interval for `Tueday`
     */
    tue: outputs.ClientBlockedServicesPauseScheduleTue;
    /**
     * Paused service blocking interval for `Wednesday`
     */
    wed: outputs.ClientBlockedServicesPauseScheduleWed;
}

export interface ClientBlockedServicesPauseScheduleFri {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleMon {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleSat {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleSun {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleThu {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleTue {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientBlockedServicesPauseScheduleWed {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ClientSafesearch {
    /**
     * Whether Safe Search is enabled. Defaults to `false`
     */
    enabled: boolean;
    /**
     * Services which SafeSearch is enabled.
     */
    services: string[];
}

export interface ConfigBlockedServicesPauseSchedule {
    /**
     * Paused service blocking interval for `Friday`
     */
    fri: outputs.ConfigBlockedServicesPauseScheduleFri;
    /**
     * Paused service blocking interval for `Monday`
     */
    mon: outputs.ConfigBlockedServicesPauseScheduleMon;
    /**
     * Paused service blocking interval for `Saturday`
     */
    sat: outputs.ConfigBlockedServicesPauseScheduleSat;
    /**
     * Paused service blocking interval for `Sunday`
     */
    sun: outputs.ConfigBlockedServicesPauseScheduleSun;
    /**
     * Paused service blocking interval for `Thursday`
     */
    thu: outputs.ConfigBlockedServicesPauseScheduleThu;
    /**
     * Time zone name according to IANA time zone database. For example `America/New_York`. `Local` represents the system's local time zone.
     */
    timeZone?: string;
    /**
     * Paused service blocking interval for `Tueday`
     */
    tue: outputs.ConfigBlockedServicesPauseScheduleTue;
    /**
     * Paused service blocking interval for `Wednesday`
     */
    wed: outputs.ConfigBlockedServicesPauseScheduleWed;
}

export interface ConfigBlockedServicesPauseScheduleFri {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleMon {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleSat {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleSun {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleThu {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleTue {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigBlockedServicesPauseScheduleWed {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end?: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start?: string;
}

export interface ConfigDhcp {
    /**
     * Whether the DHCP server is enabled. Defaults to `false`
     */
    enabled: boolean;
    /**
     * The interface to use for the DHCP server
     */
    interface: string;
    ipv4Settings: outputs.ConfigDhcpIpv4Settings;
    ipv6Settings: outputs.ConfigDhcpIpv6Settings;
    /**
     * Static leases for the DHCP server
     */
    staticLeases: outputs.ConfigDhcpStaticLease[];
}

export interface ConfigDhcpIpv4Settings {
    /**
     * The gateway IP for the DHCP server scope
     */
    gatewayIp: string;
    /**
     * The lease duration for the DHCP server scope, in seconds. Defaults to `0`
     */
    leaseDuration: number;
    /**
     * The start range for the DHCP server scope
     */
    rangeEnd: string;
    /**
     * The start range for the DHCP server scope
     */
    rangeStart: string;
    /**
     * The subnet mask for the DHCP server scope
     */
    subnetMask: string;
}

export interface ConfigDhcpIpv6Settings {
    /**
     * The lease duration for the DHCP server scope, in seconds. Defaults to `86400`
     */
    leaseDuration: number;
    /**
     * The start range for the DHCP server scope
     */
    rangeStart: string;
}

export interface ConfigDhcpStaticLease {
    /**
     * Hostname associated with the static lease
     */
    hostname: string;
    /**
     * IP address associated with the static lease
     */
    ip: string;
    /**
     * MAC address associated with the static lease
     */
    mac: string;
}

export interface ConfigDns {
    /**
     * The allowlist of clients: IP addresses, CIDRs, or ClientIDs
     */
    allowedClients: string[];
    /**
     * Disallowed domains. Defaults to the ones supplied by the default AdGuard Home configuration
     */
    blockedHosts: string[];
    /**
     * How many seconds the clients should cache a filtered response. Defaults to `10`
     */
    blockedResponseTtl: number;
    /**
     * When `blocking_mode` is set to `custom_ip`, the IPv4 address to be returned for a blocked A request
     */
    blockingIpv4: string;
    /**
     * When `blocking_mode` is set to `custom_ip`, the IPv6 address to be returned for a blocked A request
     */
    blockingIpv6: string;
    /**
     * DNS response sent when request is blocked. Valid values are `default` (the default), `refused`, `nxdomain`, `null_ip` or `custom_ip`
     */
    blockingMode: string;
    /**
     * Booststrap DNS servers. Defaults to the ones supplied by the default AdGuard Home configuration
     */
    bootstrapDns: string[];
    /**
     * Whether optimistic DNS caching is enabled. Defaults to `false`
     */
    cacheOptimistic: boolean;
    /**
     * DNS cache size (in bytes). Defaults to `4194304`
     */
    cacheSize: number;
    /**
     * Overridden maximum TTL (in seconds) received from upstream DNS servers. Defaults to `0`
     */
    cacheTtlMax: number;
    /**
     * Overridden minimum TTL (in seconds) received from upstream DNS servers. Defaults to `0`
     */
    cacheTtlMin: number;
    /**
     * Whether dropping of all IPv6 DNS queries is enabled. Defaults to `false`
     */
    disableIpv6: boolean;
    /**
     * The blocklist of clients: IP addresses, CIDRs, or ClientIDs
     */
    disallowedClients: string[];
    /**
     * Whether outgoing DNSSEC is enabled. Defaults to `false`
     */
    dnssecEnabled: boolean;
    /**
     * The custom IP for EDNS Client Subnet (ECS)
     */
    ednsCsCustomIp: string;
    /**
     * Whether EDNS Client Subnet (ECS) is enabled. Defaults to `false`
     */
    ednsCsEnabled: boolean;
    /**
     * Whether EDNS Client Subnet (ECS) is using a custom IP. Defaults to `false`
     */
    ednsCsUseCustom: boolean;
    /**
     * Fallback DNS servers
     */
    fallbackDns: string[];
    /**
     * Set of private reverse DNS servers
     */
    localPtrUpstreams: string[];
    /**
     * Whether protection is enabled. Defaults to `true`
     */
    protectionEnabled: boolean;
    /**
     * The number of requests per second allowed per client. Defaults to `20`
     */
    rateLimit: number;
    /**
     * Subnet prefix length for IPv4 addresses used for rate limiting. Defaults to `24`
     */
    rateLimitSubnetLenIpv4: number;
    /**
     * Subnet prefix length for IPv6 addresses used for rate limiting. Defaults to `56`
     */
    rateLimitSubnetLenIpv6: number;
    /**
     * IP addresses excluded from rate limiting
     */
    rateLimitWhitelists: string[];
    /**
     * Whether reverse DNS resolution of clients' IP addresses is enabled. Defaults to `true`
     */
    resolveClients: boolean;
    /**
     * Upstream DNS servers. Defaults to the ones supplied by the default AdGuard Home configuration
     */
    upstreamDns: string[];
    /**
     * Upstream DNS resolvers usage strategy. Valid values are `load_balance` (default), `parallel` and `fastest_addr`
     */
    upstreamMode: string;
    /**
     * The number of seconds to wait for a response from the upstream server. Defaults to `10`
     */
    upstreamTimeout: number;
    /**
     * Whether to use private reverse DNS resolvers. Defaults to `false`
     */
    usePrivatePtrResolvers: boolean;
}

export interface ConfigFiltering {
    /**
     * Whether DNS filtering is enabled. Defaults to `true`
     */
    enabled: boolean;
    /**
     * Update interval for all list-based filters, in hours. Defaults to `24`
     */
    updateInterval: number;
}

export interface ConfigQuerylog {
    /**
     * Whether anonymizing clients' IP addresses is enabled. Defaults to `false`
     */
    anonymizeClientIp: boolean;
    /**
     * Whether the query log is enabled. Defaults to `true`
     */
    enabled: boolean;
    /**
     * Set of host names which should not be written to log
     */
    ignoreds: string[];
    /**
     * Time period for query log rotation, in hours. Defaults to `2160` (90 days)
     */
    interval: number;
}

export interface ConfigSafesearch {
    /**
     * Whether Safe Search is enabled. Defaults to `false`
     */
    enabled: boolean;
    /**
     * Services which SafeSearch is enabled.
     */
    services: string[];
}

export interface ConfigStats {
    /**
     * Whether server statistics are enabled. Defaults to `true`
     */
    enabled: boolean;
    /**
     * Set of host names which should not be counted in the server statistics
     */
    ignoreds: string[];
    /**
     * Time period for server statistics rotation, in hours. Defaults to `24` (1 day)
     */
    interval: number;
}

export interface ConfigTls {
    /**
     * The certificates chain. Supply either a path to a file or a base64 encoded string of the certificates chain in PEM format
     */
    certificateChain: string;
    /**
     * The value of SubjectAltNames field of the first certificate in the chain
     */
    dnsNames: string[];
    /**
     * Whether encryption (DoT/DoH/HTTPS) is enabled
     */
    enabled: boolean;
    /**
     * When `true`, forces HTTP-to-HTTPS redirect. Defaults to `false`
     */
    forceHttps: boolean;
    /**
     * The issuer of the first certificate in the chain
     */
    issuer: string;
    /**
     * The private key type, either `RSA` or `ECDSA`
     */
    keyType: string;
    /**
     * The NotAfter field of the first certificate in the chain
     */
    notAfter: string;
    /**
     * The NotBefore field of the first certificate in the chain
     */
    notBefore: string;
    /**
     * The DNS-over-Quic (DoQ) port. Set to `0` to disable. Defaults to `853`
     */
    portDnsOverQuic: number;
    /**
     * The DNS-over-TLS (DoT) port. Set to `0` to disable. Defaults to `853`
     */
    portDnsOverTls: number;
    /**
     * The HTTPS port. Set to `0` to disable. Defaults to `443`
     */
    portHttps: number;
    /**
     * The private key. Supply either a path to a file or a base64 encoded string of the private key in PEM format
     */
    privateKey: string;
    /**
     * Whether the user has previously saved a private key
     */
    privateKeySaved: boolean;
    /**
     * When `true`, plain DNS is allowed for incoming requests. Defaults to `true`
     */
    servePlainDns: boolean;
    /**
     * The hostname of the TLS/HTTPS server
     */
    serverName: string;
    /**
     * The subject of the first certificate in the chain
     */
    subject: string;
    /**
     * Whether the specified certificates chain is a valid chain of X.509 certificates
     */
    validCert: boolean;
    /**
     * Whether the specified certificates chain is verified and issued by a known CA
     */
    validChain: boolean;
    /**
     * Whether the private key is valid
     */
    validKey: boolean;
    /**
     * Whether both certificate and private key are correct
     */
    validPair: boolean;
    /**
     * The validation warning message with the issue description
     */
    warningValidation: string;
}

export interface GetClientBlockedServicesPauseSchedule {
    /**
     * Paused service blocking interval for `Friday`
     */
    fri: outputs.GetClientBlockedServicesPauseScheduleFri;
    /**
     * Paused service blocking interval for `Monday`
     */
    mon: outputs.GetClientBlockedServicesPauseScheduleMon;
    /**
     * Paused service blocking interval for `Saturday`
     */
    sat: outputs.GetClientBlockedServicesPauseScheduleSat;
    /**
     * Paused service blocking interval for `Sunday`
     */
    sun: outputs.GetClientBlockedServicesPauseScheduleSun;
    /**
     * Paused service blocking interval for `Thursday`
     */
    thu: outputs.GetClientBlockedServicesPauseScheduleThu;
    /**
     * Time zone name according to IANA time zone database. For example `America/New_York`. `Local` represents the system's local time zone.
     */
    timeZone: string;
    /**
     * Paused service blocking interval for `Tueday`
     */
    tue: outputs.GetClientBlockedServicesPauseScheduleTue;
    /**
     * Paused service blocking interval for `Wednesday`
     */
    wed: outputs.GetClientBlockedServicesPauseScheduleWed;
}

export interface GetClientBlockedServicesPauseScheduleFri {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleMon {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleSat {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleSun {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleThu {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleTue {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientBlockedServicesPauseScheduleWed {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetClientSafesearch {
    /**
     * Whether Safe Search is enabled
     */
    enabled: boolean;
    /**
     * Services which SafeSearch is enabled
     */
    services: string[];
}

export interface GetConfigBlockedServicesPauseSchedule {
    /**
     * Paused service blocking interval for `Friday`
     */
    fri: outputs.GetConfigBlockedServicesPauseScheduleFri;
    /**
     * Paused service blocking interval for `Monday`
     */
    mon: outputs.GetConfigBlockedServicesPauseScheduleMon;
    /**
     * Paused service blocking interval for `Saturday`
     */
    sat: outputs.GetConfigBlockedServicesPauseScheduleSat;
    /**
     * Paused service blocking interval for `Sunday`
     */
    sun: outputs.GetConfigBlockedServicesPauseScheduleSun;
    /**
     * Paused service blocking interval for `Thursday`
     */
    thu: outputs.GetConfigBlockedServicesPauseScheduleThu;
    /**
     * Time zone name according to IANA time zone database. For example `America/New_York`. `Local` represents the system's local time zone.
     */
    timeZone: string;
    /**
     * Paused service blocking interval for `Tueday`
     */
    tue: outputs.GetConfigBlockedServicesPauseScheduleTue;
    /**
     * Paused service blocking interval for `Wednesday`
     */
    wed: outputs.GetConfigBlockedServicesPauseScheduleWed;
}

export interface GetConfigBlockedServicesPauseScheduleFri {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleMon {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleSat {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleSun {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleThu {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleTue {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigBlockedServicesPauseScheduleWed {
    /**
     * End of paused service blocking schedule, in HH:MM format
     */
    end: string;
    /**
     * Start of paused service blocking schedule, in HH:MM format
     */
    start: string;
}

export interface GetConfigDhcp {
    /**
     * Whether the DHCP server is enabled
     */
    enabled: boolean;
    /**
     * The interface to use for the DHCP server
     */
    interface: string;
    ipv4Settings: outputs.GetConfigDhcpIpv4Settings;
    ipv6Settings: outputs.GetConfigDhcpIpv6Settings;
    /**
     * Current leases in the DHCP server
     */
    leases: outputs.GetConfigDhcpLease[];
    /**
     * Current static leases in the DHCP server
     */
    staticLeases: outputs.GetConfigDhcpStaticLease[];
}

export interface GetConfigDhcpIpv4Settings {
    /**
     * The gateway IP for the DHCP server scope
     */
    gatewayIp: string;
    /**
     * The lease duration for the DHCP server scope, in seconds
     */
    leaseDuration: number;
    /**
     * The start range for the DHCP server scope
     */
    rangeEnd: string;
    /**
     * The start range for the DHCP server scope
     */
    rangeStart: string;
    /**
     * The subnet mask for the DHCP server scope
     */
    subnetMask: string;
}

export interface GetConfigDhcpIpv6Settings {
    /**
     * The lease duration for the DHCP server scope
     */
    leaseDuration: number;
    /**
     * The start range for the DHCP server scope
     */
    rangeStart: string;
}

export interface GetConfigDhcpLease {
    /**
     * Expiration timestamp for the lease
     */
    expires: string;
    /**
     * Hostname associated with the lease
     */
    hostname: string;
    /**
     * IP address associated with the lease
     */
    ip: string;
    /**
     * MAC address associated with the lease
     */
    mac: string;
}

export interface GetConfigDhcpStaticLease {
    /**
     * Hostname associated with the static lease
     */
    hostname: string;
    /**
     * IP address associated with the static lease
     */
    ip: string;
    /**
     * MAC address associated with the static lease
     */
    mac: string;
}

export interface GetConfigDns {
    /**
     * The allowlist of clients: IP addresses, CIDRs, or ClientIDs
     */
    allowedClients: string[];
    /**
     * Disallowed domains
     */
    blockedHosts: string[];
    /**
     * How many seconds the clients should cache a filtered response
     */
    blockedResponseTtl: number;
    /**
     * When `blocking_mode` is set to `custom_ip`, the IPv4 address to be returned for a blocked A request
     */
    blockingIpv4: string;
    /**
     * When `blocking_mode` is set to `custom_ip`, the IPv6 address to be returned for a blocked A request
     */
    blockingIpv6: string;
    /**
     * DNS response sent when request is blocked
     */
    blockingMode: string;
    /**
     * Booststrap DNS servers
     */
    bootstrapDns: string[];
    /**
     * Whether optimistic DNS caching is enabled
     */
    cacheOptimistic: boolean;
    /**
     * DNS cache size (in bytes)
     */
    cacheSize: number;
    /**
     * Overridden maximum TTL received from upstream DNS servers
     */
    cacheTtlMax: number;
    /**
     * Overridden minimum TTL received from upstream DNS servers
     */
    cacheTtlMin: number;
    /**
     * Whether dropping of all IPv6 DNS queries is enabled
     */
    disableIpv6: boolean;
    /**
     * The blocklist of clients: IP addresses, CIDRs, or ClientIDs
     */
    disallowedClients: string[];
    /**
     * Whether outgoing DNSSEC is enabled
     */
    dnssecEnabled: boolean;
    /**
     * The custom IP being used for EDNS Client Subnet (ECS)
     */
    ednsCsCustomIp: string;
    /**
     * Whether EDNS Client Subnet (ECS) is enabled
     */
    ednsCsEnabled: boolean;
    /**
     * Whether EDNS Client Subnet (ECS) is using a custom IP
     */
    ednsCsUseCustom: boolean;
    /**
     * Fallback DNS servers
     */
    fallbackDns: string[];
    /**
     * Set of private reverse DNS servers
     */
    localPtrUpstreams: string[];
    /**
     * Whether protection is enabled
     */
    protectionEnabled: boolean;
    /**
     * The number of requests per second allowed per client
     */
    rateLimit: number;
    /**
     * Subnet prefix length for IPv4 addresses used for rate limiting
     */
    rateLimitSubnetLenIpv4: number;
    /**
     * Subnet prefix length for IPv6 addresses used for rate limiting
     */
    rateLimitSubnetLenIpv6: number;
    /**
     * IP addresses excluded from rate limiting
     */
    rateLimitWhitelists: string[];
    /**
     * Whether reverse DNS resolution of clients' IP addresses is enabled
     */
    resolveClients: boolean;
    /**
     * Upstream DNS servers
     */
    upstreamDns: string[];
    /**
     * Upstream DNS resolvers usage strategy
     */
    upstreamMode: string;
    /**
     * The number of seconds to wait for a response from the upstream server
     */
    upstreamTimeout: number;
    /**
     * Whether to use private reverse DNS resolvers
     */
    usePrivatePtrResolvers: boolean;
}

export interface GetConfigFiltering {
    /**
     * Whether DNS filtering is enabled
     */
    enabled: boolean;
    /**
     * Update interval for all list-based filters, in hours
     */
    updateInterval: number;
}

export interface GetConfigQuerylog {
    /**
     * Whether anonymizing clients' IP addresses is enabled
     */
    anonymizeClientIp: boolean;
    /**
     * Whether the query log is enabled
     */
    enabled: boolean;
    /**
     * Set of host names which should not be written to log
     */
    ignoreds: string[];
    /**
     * Time period for query log rotation, in hours
     */
    interval: number;
}

export interface GetConfigSafesearch {
    /**
     * Whether Safe Search is enabled
     */
    enabled: boolean;
    /**
     * Services which SafeSearch is enabled
     */
    services: string[];
}

export interface GetConfigStats {
    /**
     * Whether server statistics enabled
     */
    enabled: boolean;
    /**
     * Set of host names which should not be counted in the server statistics
     */
    ignoreds: string[];
    /**
     * Time period for the server statistics rotation, in hours
     */
    interval: number;
}

export interface GetConfigTls {
    /**
     * The certificates chain, either the path to a file or a base64 encoded string of the certificates chain in PEM format
     */
    certificateChain: string;
    /**
     * The value of SubjectAltNames field of the first certificate in the chain
     */
    dnsNames: string[];
    /**
     * Whether encryption (DoT/DoH/HTTPS) is enabled
     */
    enabled: boolean;
    /**
     * When `true`, forces HTTP-to-HTTPS redirect
     */
    forceHttps: boolean;
    /**
     * The issuer of the first certificate in the chain
     */
    issuer: string;
    /**
     * The private key type, either `RSA` or `ECDSA`
     */
    keyType: string;
    /**
     * The NotAfter field of the first certificate in the chain
     */
    notAfter: string;
    /**
     * The NotBefore field of the first certificate in the chain
     */
    notBefore: string;
    /**
     * The DNS-over-Quic (DoQ) port
     */
    portDnsOverQuic: number;
    /**
     * The DNS-over-TLS (DoT) port
     */
    portDnsOverTls: number;
    /**
     * The HTTPS port
     */
    portHttps: number;
    /**
     * The private key, either the path to a file or a base64 encoded string of the private key in PEM format
     */
    privateKey: string;
    /**
     * Whether the user has previously saved a private key
     */
    privateKeySaved: boolean;
    /**
     * When `true`, plain DNS is allowed for incoming requests
     */
    servePlainDns: boolean;
    /**
     * The hostname of the TLS/HTTPS server
     */
    serverName: string;
    /**
     * The subject of the first certificate in the chain
     */
    subject: string;
    /**
     * Whether the specified certificates chain is a valid chain of X.509 certificates
     */
    validCert: boolean;
    /**
     * Whether the specified certificates chain is verified and issued by a known CA
     */
    validChain: boolean;
    /**
     * Whether the private key is valid
     */
    validKey: boolean;
    /**
     * Whether both certificate and private key are correct
     */
    validPair: boolean;
    /**
     * The validation warning message with the issue description
     */
    warningValidation: string;
}

